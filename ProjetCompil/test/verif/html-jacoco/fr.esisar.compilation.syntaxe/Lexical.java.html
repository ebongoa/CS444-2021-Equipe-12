<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Lexical.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Coverage Report</a> &gt; <a href="index.source.html" class="el_package">fr.esisar.compilation.syntaxe</a> &gt; <span class="el_source">Lexical.java</span></div><h1>Lexical.java</h1><pre class="source lang-java linenums">/* The following code was generated by JFlex 1.4.3 on 13/09/20 16:23 */

// ---------------------------------------------------------------------------
// Fichier d'entrée JFLex pour l'analyseur lexical
// ---------------------------------------------------------------------------

package fr.esisar.compilation.syntaxe;

import java_cup.runtime.*;
import java.util.Hashtable;

/**
 * La classe Lexical permet de realiser l'analyse lexicale.
 */


public class Lexical implements java_cup.runtime.Scanner {

  /** This character denotes the end of file */
  public static final int YYEOF = -1;

  /** initial size of the lookahead buffer */
  private static final int ZZ_BUFFERSIZE = 16384;

  /** lexical states */
  public static final int YYINITIAL = 0;

  /**
   * ZZ_LEXSTATE[l] is the state in the DFA for the lexical state l
   * ZZ_LEXSTATE[l+1] is the state in the DFA for the lexical state l
   *                  at the beginning of a line
   * l is of the form l = 2*k, k a non negative integer
   */
<span class="fc" id="L34">  private static final int ZZ_LEXSTATE[] = { </span>
     0, 0
  };

  /** 
   * Translates characters to character classes
   */
  private static final String ZZ_CMAP_PACKED = 
    &quot;\11\0\1\1\1\2\25\0\1\1\12\0\1\3\4\0\12\0\7\0&quot;+
    &quot;\32\0\6\0\32\0\uff85\0&quot;;

  /** 
   * Translates characters to character classes
   */
<span class="fc" id="L48">  private static final char [] ZZ_CMAP = zzUnpackCMap(ZZ_CMAP_PACKED);</span>

  /** 
   * Translates DFA states to action switch labels.
   */
<span class="fc" id="L53">  private static final int [] ZZ_ACTION = zzUnpackAction();</span>

  private static final String ZZ_ACTION_PACKED_0 =
    &quot;\1\0\1\1\2\2\1\3&quot;;

  private static int [] zzUnpackAction() {
<span class="fc" id="L59">    int [] result = new int[5];</span>
<span class="fc" id="L60">    int offset = 0;</span>
<span class="fc" id="L61">    offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);</span>
<span class="fc" id="L62">    return result;</span>
  }

  private static int zzUnpackAction(String packed, int offset, int [] result) {
<span class="fc" id="L66">    int i = 0;       /* index in packed string  */</span>
<span class="fc" id="L67">    int j = offset;  /* index in unpacked array */</span>
<span class="fc" id="L68">    int l = packed.length();</span>
<span class="fc bfc" id="L69" title="All 2 branches covered.">    while (i &lt; l) {</span>
<span class="fc" id="L70">      int count = packed.charAt(i++);</span>
<span class="fc" id="L71">      int value = packed.charAt(i++);</span>
<span class="fc bfc" id="L72" title="All 2 branches covered.">      do result[j++] = value; while (--count &gt; 0);</span>
<span class="fc" id="L73">    }</span>
<span class="fc" id="L74">    return j;</span>
  }


  /** 
   * Translates a state to a row index in the transition table
   */
<span class="fc" id="L81">  private static final int [] ZZ_ROWMAP = zzUnpackRowMap();</span>

  private static final String ZZ_ROWMAP_PACKED_0 =
    &quot;\0\0\0\4\0\10\0\4\0\4&quot;;

  private static int [] zzUnpackRowMap() {
<span class="fc" id="L87">    int [] result = new int[5];</span>
<span class="fc" id="L88">    int offset = 0;</span>
<span class="fc" id="L89">    offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);</span>
<span class="fc" id="L90">    return result;</span>
  }

  private static int zzUnpackRowMap(String packed, int offset, int [] result) {
<span class="fc" id="L94">    int i = 0;  /* index in packed string  */</span>
<span class="fc" id="L95">    int j = offset;  /* index in unpacked array */</span>
<span class="fc" id="L96">    int l = packed.length();</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">    while (i &lt; l) {</span>
<span class="fc" id="L98">      int high = packed.charAt(i++) &lt;&lt; 16;</span>
<span class="fc" id="L99">      result[j++] = high | packed.charAt(i++);</span>
<span class="fc" id="L100">    }</span>
<span class="fc" id="L101">    return j;</span>
  }

  /** 
   * The transition table of the DFA
   */
<span class="fc" id="L107">  private static final int [] ZZ_TRANS = zzUnpackTrans();</span>

  private static final String ZZ_TRANS_PACKED_0 =
    &quot;\1\2\1\3\1\4\1\5\5\0\1\3\2\0&quot;;

  private static int [] zzUnpackTrans() {
<span class="fc" id="L113">    int [] result = new int[12];</span>
<span class="fc" id="L114">    int offset = 0;</span>
<span class="fc" id="L115">    offset = zzUnpackTrans(ZZ_TRANS_PACKED_0, offset, result);</span>
<span class="fc" id="L116">    return result;</span>
  }

  private static int zzUnpackTrans(String packed, int offset, int [] result) {
<span class="fc" id="L120">    int i = 0;       /* index in packed string  */</span>
<span class="fc" id="L121">    int j = offset;  /* index in unpacked array */</span>
<span class="fc" id="L122">    int l = packed.length();</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">    while (i &lt; l) {</span>
<span class="fc" id="L124">      int count = packed.charAt(i++);</span>
<span class="fc" id="L125">      int value = packed.charAt(i++);</span>
<span class="fc" id="L126">      value--;</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">      do result[j++] = value; while (--count &gt; 0);</span>
<span class="fc" id="L128">    }</span>
<span class="fc" id="L129">    return j;</span>
  }


  /* error codes */
  private static final int ZZ_UNKNOWN_ERROR = 0;
  private static final int ZZ_NO_MATCH = 1;
  private static final int ZZ_PUSHBACK_2BIG = 2;

  /* error messages for the codes above */
<span class="fc" id="L139">  private static final String ZZ_ERROR_MSG[] = {</span>
    &quot;Unkown internal scanner error&quot;,
    &quot;Error: could not match input&quot;,
    &quot;Error: pushback value was too large&quot;
  };

  /**
   * ZZ_ATTRIBUTE[aState] contains the attributes of state &lt;code&gt;aState&lt;/code&gt;
   */
<span class="fc" id="L148">  private static final int [] ZZ_ATTRIBUTE = zzUnpackAttribute();</span>

  private static final String ZZ_ATTRIBUTE_PACKED_0 =
    &quot;\1\0\1\11\1\1\2\11&quot;;

  private static int [] zzUnpackAttribute() {
<span class="fc" id="L154">    int [] result = new int[5];</span>
<span class="fc" id="L155">    int offset = 0;</span>
<span class="fc" id="L156">    offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);</span>
<span class="fc" id="L157">    return result;</span>
  }

  private static int zzUnpackAttribute(String packed, int offset, int [] result) {
<span class="fc" id="L161">    int i = 0;       /* index in packed string  */</span>
<span class="fc" id="L162">    int j = offset;  /* index in unpacked array */</span>
<span class="fc" id="L163">    int l = packed.length();</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">    while (i &lt; l) {</span>
<span class="fc" id="L165">      int count = packed.charAt(i++);</span>
<span class="fc" id="L166">      int value = packed.charAt(i++);</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">      do result[j++] = value; while (--count &gt; 0);</span>
<span class="fc" id="L168">    }</span>
<span class="fc" id="L169">    return j;</span>
  }

  /** the input device */
  private java.io.Reader zzReader;

  /** the current state of the DFA */
  private int zzState;

  /** the current lexical state */
<span class="fc" id="L179">  private int zzLexicalState = YYINITIAL;</span>

  /** this buffer contains the current text to be matched and is
      the source of the yytext() string */
<span class="fc" id="L183">  private char zzBuffer[] = new char[ZZ_BUFFERSIZE];</span>

  /** the textposition at the last accepting state */
  private int zzMarkedPos;

  /** the current text position in the buffer */
  private int zzCurrentPos;

  /** startRead marks the beginning of the yytext() string in the buffer */
  private int zzStartRead;

  /** endRead marks the last character in the buffer, that has been read
      from input */
  private int zzEndRead;

  /** number of newlines encountered up to the start of the matched text */
  private int yyline;

  /** the number of characters up to the start of the matched text */
  private int yychar;

  /**
   * the number of characters from the last newline up to the start of the 
   * matched text
   */
  private int yycolumn;

  /** 
   * zzAtBOL == true &lt;=&gt; the scanner is currently at the beginning of a line
   */
<span class="fc" id="L213">  private boolean zzAtBOL = true;</span>

  /** zzAtEOF == true &lt;=&gt; the scanner is at the EOF */
  private boolean zzAtEOF;

  /** denotes if the user-EOF-code has already been executed */
  private boolean zzEOFDone;

  /* user code: */
   /**
    * Le dictionnaire associe à chaque mot réservé le code du lexème 
    * correspondant.
    */
<span class="fc" id="L226">   private final Hashtable&lt;String,Integer&gt; </span>
<span class="fc" id="L227">      dictionnaire = initialiserDictionnaire(); </span>

   /**
    * Initialisation du dictionnaire.
    */
   static Hashtable&lt;String,Integer&gt; initialiserDictionnaire() {
<span class="fc" id="L233">      Hashtable&lt;String,Integer&gt; dico = new Hashtable&lt;String,Integer&gt;();</span>
<span class="fc" id="L234">      dico.put(&quot;and&quot;, sym.AND);</span>
<span class="fc" id="L235">      dico.put(&quot;array&quot;, sym.ARRAY);</span>
<span class="fc" id="L236">      dico.put(&quot;begin&quot;, sym.BEGIN);</span>
<span class="fc" id="L237">      dico.put(&quot;div&quot;, sym.DIV);</span>
<span class="fc" id="L238">      dico.put(&quot;do&quot;, sym.DO);</span>
<span class="fc" id="L239">      dico.put(&quot;downto&quot;, sym.DOWNTO);</span>
<span class="fc" id="L240">      dico.put(&quot;end&quot;, sym.END);</span>
<span class="fc" id="L241">      dico.put(&quot;else&quot;, sym.ELSE);</span>
<span class="fc" id="L242">      dico.put(&quot;for&quot;, sym.FOR);</span>
<span class="fc" id="L243">      dico.put(&quot;if&quot;, sym.IF);</span>
<span class="fc" id="L244">      dico.put(&quot;mod&quot;, sym.MOD);</span>
<span class="fc" id="L245">      dico.put(&quot;new_line&quot;, sym.NEW_LINE);</span>
<span class="fc" id="L246">      dico.put(&quot;not&quot;, sym.NOT);</span>
<span class="fc" id="L247">      dico.put(&quot;null&quot;, sym.NULL);</span>
<span class="fc" id="L248">      dico.put(&quot;of&quot;, sym.OF);</span>
<span class="fc" id="L249">      dico.put(&quot;or&quot;, sym.OR);</span>
<span class="fc" id="L250">      dico.put(&quot;program&quot;, sym.PROGRAM);</span>
<span class="fc" id="L251">      dico.put(&quot;read&quot;, sym.READ);</span>
<span class="fc" id="L252">      dico.put(&quot;then&quot;, sym.THEN);</span>
<span class="fc" id="L253">      dico.put(&quot;to&quot;, sym.TO);</span>
<span class="fc" id="L254">      dico.put(&quot;while&quot;, sym.WHILE);</span>
<span class="fc" id="L255">      dico.put(&quot;write&quot;, sym.WRITE);</span>
<span class="fc" id="L256">      return dico;</span>
   }

   /**
    * Le numéro de la ligne courante.
    */
   int numLigne() {
<span class="fc" id="L263">      return yyline + 1;</span>
   }

   private Symbol symbol(int code_lexeme) {
<span class="nc" id="L267">      return new Symbol(code_lexeme, numLigne(), 0);</span>
   }

   private Symbol symbol(int code_lexeme, Object value) {
<span class="nc" id="L271">      return new Symbol(code_lexeme, numLigne(), 0, value);</span>
   }

   /**
    * Convertit un code de lexème en String correspondante.
    */
   static String toString(int code_lexeme) {
<span class="nc bnc" id="L278" title="All 47 branches missed.">      switch (code_lexeme) {</span>
         case sym.IDF: 
<span class="nc" id="L280">            return &quot;IDF&quot;;</span>
         case sym.CONST_ENT:
<span class="nc" id="L282">            return &quot;CONST_ENT&quot;;</span>
         case sym.CONST_REEL:
<span class="nc" id="L284">            return &quot;CONST_REEL&quot;;</span>
         case sym.CONST_CHAINE:
<span class="nc" id="L286">            return &quot;CONST_CHAINE&quot;;</span>
         case sym.AND:
<span class="nc" id="L288">            return &quot;AND&quot;;</span>
         case sym.ARRAY:
<span class="nc" id="L290">            return &quot;ARRAY&quot;;</span>
         case sym.BEGIN:
<span class="nc" id="L292">            return &quot;BEGIN&quot;;</span>
         case sym.DIV:
<span class="nc" id="L294">            return &quot;DIV&quot;;</span>
         case sym.DO:
<span class="nc" id="L296">            return &quot;DO&quot;;</span>
         case sym.DOWNTO:
<span class="nc" id="L298">            return &quot;DOWNTO&quot;;</span>
         case sym.ELSE:
<span class="nc" id="L300">            return &quot;ELSE&quot;;</span>
         case sym.END:
<span class="nc" id="L302">            return &quot;END&quot;;</span>
         case sym.FOR:
<span class="nc" id="L304">            return &quot;FOR&quot;;</span>
         case sym.IF:
<span class="nc" id="L306">            return &quot;IF&quot;;</span>
         case sym.MOD:
<span class="nc" id="L308">            return &quot;MOD&quot;;</span>
         case sym.NEW_LINE:
<span class="nc" id="L310">            return &quot;NEW_LINE&quot;;</span>
         case sym.NOT:
<span class="nc" id="L312">            return &quot;NOT&quot;;</span>
         case sym.NULL:
<span class="nc" id="L314">            return &quot;NULL&quot;;</span>
         case sym.OF:
<span class="nc" id="L316">            return &quot;OF&quot;;</span>
         case sym.OR:
<span class="nc" id="L318">            return &quot;OR&quot;;</span>
         case sym.PROGRAM:
<span class="nc" id="L320">            return &quot;PROGRAM&quot;;</span>
         case sym.READ:
<span class="nc" id="L322">            return &quot;READ&quot;;</span>
         case sym.THEN:
<span class="nc" id="L324">            return &quot;THEN&quot;;</span>
         case sym.TO:
<span class="nc" id="L326">            return &quot;TO&quot;;</span>
         case sym.WHILE:
<span class="nc" id="L328">            return &quot;WHILE&quot;;</span>
         case sym.WRITE:
<span class="nc" id="L330">            return &quot;WRITE&quot;;</span>
         case sym.INF:
<span class="nc" id="L332">            return &quot;INF&quot;;</span>
         case sym.SUP:
<span class="nc" id="L334">            return &quot;SUP&quot;;</span>
         case sym.EGAL:
<span class="nc" id="L336">            return &quot;EGAL&quot;;</span>
         case sym.DIFF:
<span class="nc" id="L338">            return &quot;DIFF&quot;;</span>
         case sym.INF_EGAL:
<span class="nc" id="L340">            return &quot;INF_EGAL&quot;;</span>
         case sym.SUP_EGAL:
<span class="nc" id="L342">            return &quot;SUP_EGAL&quot;;</span>
         case sym.PLUS:
<span class="nc" id="L344">            return &quot;PLUS&quot;;</span>
         case sym.MOINS:
<span class="nc" id="L346">            return &quot;MOINS&quot;;</span>
         case sym.MULT:
<span class="nc" id="L348">            return &quot;MULT&quot;;</span>
         case sym.DIV_REEL:
<span class="nc" id="L350">            return &quot;DIV_REEL&quot;;</span>
         case sym.PAR_OUVR:
<span class="nc" id="L352">            return &quot;PAR_OUVR&quot;;</span>
         case sym.PAR_FERM:
<span class="nc" id="L354">            return &quot;PAR_FERM&quot;;</span>
         case sym.DOUBLE_POINT:
<span class="nc" id="L356">            return &quot;DOUBLE_POINT&quot;;</span>
         case sym.DEUX_POINTS:
<span class="nc" id="L358">            return &quot;DEUX_POINTS&quot;;</span>
         case sym.VIRGULE:
<span class="nc" id="L360">            return &quot;VIRGULE&quot;;</span>
         case sym.POINT_VIRGULE:
<span class="nc" id="L362">            return &quot;POINT_VIRGULE&quot;;</span>
         case sym.CROCH_OUVR:
<span class="nc" id="L364">            return &quot;CROCH_OUVR&quot;;</span>
         case sym.CROCH_FERM:
<span class="nc" id="L366">            return &quot;CROCH_FERM&quot;;</span>
         case sym.AFFECT:
<span class="nc" id="L368">            return &quot;AFFECT&quot;;</span>
         case sym.POINT:
<span class="nc" id="L370">            return &quot;POINT&quot;;</span>
         default:
<span class="nc" id="L372">            throw new ErreurInterneLexical(</span>
               &quot;Token inconnu dans toString(int code_lexeme)&quot;);
      }
   }


   /**
    * Convertit un lexème (&quot;Symbole&quot;) en String correspondante.
    */
   static String toString(Symbol s) {
      String ts;
<span class="nc bnc" id="L383" title="All 5 branches missed.">      switch (s.sym) {</span>
         case sym.IDF:
<span class="nc" id="L385">            String nom = (String) s.value;</span>
<span class="nc" id="L386">            ts = &quot;(&quot; + nom + &quot;)&quot;;</span>
<span class="nc" id="L387">            break;</span>
         case sym.CONST_ENT:
<span class="nc" id="L389">            Integer n = (Integer) s.value;</span>
<span class="nc" id="L390">            ts = &quot;(&quot; + n.intValue() + &quot;)&quot;;</span>
<span class="nc" id="L391">            break;</span>
         case sym.CONST_REEL:
<span class="nc" id="L393">            Float f = (Float) s.value;</span>
<span class="nc" id="L394">            ts = &quot;(&quot; + f.floatValue() + &quot;)&quot;;</span>
<span class="nc" id="L395">            break;</span>
         case sym.CONST_CHAINE:
<span class="nc" id="L397">            String chaine = (String) s.value;</span>
<span class="nc" id="L398">            ts = &quot;(&quot; + chaine + &quot;)&quot;;</span>
<span class="nc" id="L399">            break;</span>

         default:
<span class="nc" id="L402">            ts = &quot;&quot;;</span>
      }
<span class="nc" id="L404">      return toString(s.sym) + ts + &quot; &quot; + s.left + &quot;:&quot; + s.right;</span>
   }


  /**
   * Creates a new scanner
   * There is also a java.io.InputStream version of this constructor.
   *
   * @param   in  the java.io.Reader to read input from.
   */
<span class="fc" id="L414">  public Lexical(java.io.Reader in) {</span>
<span class="fc" id="L415">    this.zzReader = in;</span>
<span class="fc" id="L416">  }</span>

  /**
   * Creates a new scanner.
   * There is also java.io.Reader version of this constructor.
   *
   * @param   in  the java.io.Inputstream to read input from.
   */
  public Lexical(java.io.InputStream in) {
<span class="fc" id="L425">    this(new java.io.InputStreamReader(in));</span>
<span class="fc" id="L426">  }</span>

  /** 
   * Unpacks the compressed character translation table.
   *
   * @param packed   the packed character translation table
   * @return         the unpacked character translation table
   */
  private static char [] zzUnpackCMap(String packed) {
<span class="fc" id="L435">    char [] map = new char[0x10000];</span>
<span class="fc" id="L436">    int i = 0;  /* index in packed string  */</span>
<span class="fc" id="L437">    int j = 0;  /* index in unpacked array */</span>
<span class="fc bfc" id="L438" title="All 2 branches covered.">    while (i &lt; 28) {</span>
<span class="fc" id="L439">      int  count = packed.charAt(i++);</span>
<span class="fc" id="L440">      char value = packed.charAt(i++);</span>
<span class="fc bfc" id="L441" title="All 2 branches covered.">      do map[j++] = value; while (--count &gt; 0);</span>
<span class="fc" id="L442">    }</span>
<span class="fc" id="L443">    return map;</span>
  }


  /**
   * Refills the input buffer.
   *
   * @return      &lt;code&gt;false&lt;/code&gt;, iff there was new input.
   * 
   * @exception   java.io.IOException  if any I/O-Error occurs
   */
  private boolean zzRefill() throws java.io.IOException {

    /* first: make room (if you can) */
<span class="pc bpc" id="L457" title="1 of 2 branches missed.">    if (zzStartRead &gt; 0) {</span>
<span class="nc" id="L458">      System.arraycopy(zzBuffer, zzStartRead,</span>
                       zzBuffer, 0,
                       zzEndRead-zzStartRead);

      /* translate stored positions */
<span class="nc" id="L463">      zzEndRead-= zzStartRead;</span>
<span class="nc" id="L464">      zzCurrentPos-= zzStartRead;</span>
<span class="nc" id="L465">      zzMarkedPos-= zzStartRead;</span>
<span class="nc" id="L466">      zzStartRead = 0;</span>
    }

    /* is the buffer big enough? */
<span class="pc bpc" id="L470" title="1 of 2 branches missed.">    if (zzCurrentPos &gt;= zzBuffer.length) {</span>
      /* if not: blow it up */
<span class="nc" id="L472">      char newBuffer[] = new char[zzCurrentPos*2];</span>
<span class="nc" id="L473">      System.arraycopy(zzBuffer, 0, newBuffer, 0, zzBuffer.length);</span>
<span class="nc" id="L474">      zzBuffer = newBuffer;</span>
    }

    /* finally: fill the buffer with new input */
<span class="fc" id="L478">    int numRead = zzReader.read(zzBuffer, zzEndRead,</span>
                                            zzBuffer.length-zzEndRead);

<span class="pc bpc" id="L481" title="1 of 2 branches missed.">    if (numRead &gt; 0) {</span>
<span class="fc" id="L482">      zzEndRead+= numRead;</span>
<span class="fc" id="L483">      return false;</span>
    }
    // unlikely but not impossible: read 0 characters, but not at end of stream    
<span class="nc bnc" id="L486" title="All 2 branches missed.">    if (numRead == 0) {</span>
<span class="nc" id="L487">      int c = zzReader.read();</span>
<span class="nc bnc" id="L488" title="All 2 branches missed.">      if (c == -1) {</span>
<span class="nc" id="L489">        return true;</span>
      } else {
<span class="nc" id="L491">        zzBuffer[zzEndRead++] = (char) c;</span>
<span class="nc" id="L492">        return false;</span>
      }     
    }

	// numRead &lt; 0
<span class="nc" id="L497">    return true;</span>
  }

    
  /**
   * Closes the input stream.
   */
  public final void yyclose() throws java.io.IOException {
<span class="nc" id="L505">    zzAtEOF = true;            /* indicate end of file */</span>
<span class="nc" id="L506">    zzEndRead = zzStartRead;  /* invalidate buffer    */</span>

<span class="nc bnc" id="L508" title="All 2 branches missed.">    if (zzReader != null)</span>
<span class="nc" id="L509">      zzReader.close();</span>
<span class="nc" id="L510">  }</span>


  /**
   * Resets the scanner to read from a new input stream.
   * Does not close the old reader.
   *
   * All internal variables are reset, the old input stream 
   * &lt;b&gt;cannot&lt;/b&gt; be reused (internal buffer is discarded and lost).
   * Lexical state is set to &lt;tt&gt;ZZ_INITIAL&lt;/tt&gt;.
   *
   * @param reader   the new input stream 
   */
  public final void yyreset(java.io.Reader reader) {
<span class="nc" id="L524">    zzReader = reader;</span>
<span class="nc" id="L525">    zzAtBOL  = true;</span>
<span class="nc" id="L526">    zzAtEOF  = false;</span>
<span class="nc" id="L527">    zzEOFDone = false;</span>
<span class="nc" id="L528">    zzEndRead = zzStartRead = 0;</span>
<span class="nc" id="L529">    zzCurrentPos = zzMarkedPos = 0;</span>
<span class="nc" id="L530">    yyline = yychar = yycolumn = 0;</span>
<span class="nc" id="L531">    zzLexicalState = YYINITIAL;</span>
<span class="nc" id="L532">  }</span>


  /**
   * Returns the current lexical state.
   */
  public final int yystate() {
<span class="nc" id="L539">    return zzLexicalState;</span>
  }


  /**
   * Enters a new lexical state
   *
   * @param newState the new lexical state
   */
  public final void yybegin(int newState) {
<span class="nc" id="L549">    zzLexicalState = newState;</span>
<span class="nc" id="L550">  }</span>


  /**
   * Returns the text matched by the current regular expression.
   */
  public final String yytext() {
<span class="fc" id="L557">    return new String( zzBuffer, zzStartRead, zzMarkedPos-zzStartRead );</span>
  }


  /**
   * Returns the character at position &lt;tt&gt;pos&lt;/tt&gt; from the 
   * matched text. 
   * 
   * It is equivalent to yytext().charAt(pos), but faster
   *
   * @param pos the position of the character to fetch. 
   *            A value from 0 to yylength()-1.
   *
   * @return the character at position pos
   */
  public final char yycharat(int pos) {
<span class="nc" id="L573">    return zzBuffer[zzStartRead+pos];</span>
  }


  /**
   * Returns the length of the matched text region.
   */
  public final int yylength() {
<span class="nc" id="L581">    return zzMarkedPos-zzStartRead;</span>
  }


  /**
   * Reports an error that occured while scanning.
   *
   * In a wellformed scanner (no or only correct usage of 
   * yypushback(int) and a match-all fallback rule) this method 
   * will only be called with things that &quot;Can't Possibly Happen&quot;.
   * If this method is called, something is seriously wrong
   * (e.g. a JFlex bug producing a faulty scanner etc.).
   *
   * Usual syntax/scanner level error handling should be done
   * in error fallback rules.
   *
   * @param   errorCode  the code of the errormessage to display
   */
  private void zzScanError(int errorCode) {
    String message;
    try {
<span class="nc" id="L602">      message = ZZ_ERROR_MSG[errorCode];</span>
    }
<span class="nc" id="L604">    catch (ArrayIndexOutOfBoundsException e) {</span>
<span class="nc" id="L605">      message = ZZ_ERROR_MSG[ZZ_UNKNOWN_ERROR];</span>
<span class="nc" id="L606">    }</span>

<span class="nc" id="L608">    throw new Error(message);</span>
  } 


  /**
   * Pushes the specified amount of characters back into the input stream.
   *
   * They will be read again by then next call of the scanning method
   *
   * @param number  the number of characters to be read again.
   *                This number must not be greater than yylength()!
   */
  public void yypushback(int number)  {
<span class="nc bnc" id="L621" title="All 2 branches missed.">    if ( number &gt; yylength() )</span>
<span class="nc" id="L622">      zzScanError(ZZ_PUSHBACK_2BIG);</span>

<span class="nc" id="L624">    zzMarkedPos -= number;</span>
<span class="nc" id="L625">  }</span>


  /**
   * Contains user EOF-code, which will be executed exactly once,
   * when the end of file is reached
   */
  private void zzDoEOF() throws java.io.IOException {
<span class="nc bnc" id="L633" title="All 2 branches missed.">    if (!zzEOFDone) {</span>
<span class="nc" id="L634">      zzEOFDone = true;</span>
<span class="nc" id="L635">      yyclose();</span>
    }
<span class="nc" id="L637">  }</span>


  /**
   * Resumes scanning until the next regular expression is matched,
   * the end of input is encountered or an I/O-Error occurs.
   *
   * @return      the next token
   * @exception   java.io.IOException  if any I/O-Error occurs
   */
  public java_cup.runtime.Symbol next_token() throws java.io.IOException,    ErreurLexicale
 {
    int zzInput;
    int zzAction;

    // cached fields:
    int zzCurrentPosL;
    int zzMarkedPosL;
<span class="fc" id="L655">    int zzEndReadL = zzEndRead;</span>
<span class="fc" id="L656">    char [] zzBufferL = zzBuffer;</span>
<span class="fc" id="L657">    char [] zzCMapL = ZZ_CMAP;</span>

<span class="fc" id="L659">    int [] zzTransL = ZZ_TRANS;</span>
<span class="fc" id="L660">    int [] zzRowMapL = ZZ_ROWMAP;</span>
<span class="fc" id="L661">    int [] zzAttrL = ZZ_ATTRIBUTE;</span>

    while (true) {
<span class="fc" id="L664">      zzMarkedPosL = zzMarkedPos;</span>

<span class="fc" id="L666">      boolean zzR = false;</span>
<span class="pc bpc" id="L667" title="1 of 2 branches missed.">      for (zzCurrentPosL = zzStartRead; zzCurrentPosL &lt; zzMarkedPosL;</span>
<span class="nc" id="L668">                                                             zzCurrentPosL++) {</span>
<span class="nc bnc" id="L669" title="All 4 branches missed.">        switch (zzBufferL[zzCurrentPosL]) {</span>
        case '\u000B':
        case '\u000C':
        case '\u0085':
        case '\u2028':
        case '\u2029':
<span class="nc" id="L675">          yyline++;</span>
<span class="nc" id="L676">          zzR = false;</span>
<span class="nc" id="L677">          break;</span>
        case '\r':
<span class="nc" id="L679">          yyline++;</span>
<span class="nc" id="L680">          zzR = true;</span>
<span class="nc" id="L681">          break;</span>
        case '\n':
<span class="nc bnc" id="L683" title="All 2 branches missed.">          if (zzR)</span>
<span class="nc" id="L684">            zzR = false;</span>
          else {
<span class="nc" id="L686">            yyline++;</span>
          }
<span class="nc" id="L688">          break;</span>
        default:
<span class="nc" id="L690">          zzR = false;</span>
        }
      }

<span class="pc bpc" id="L694" title="1 of 2 branches missed.">      if (zzR) {</span>
        // peek one character ahead if it is \n (if we have counted one line too much)
        boolean zzPeek;
<span class="nc bnc" id="L697" title="All 2 branches missed.">        if (zzMarkedPosL &lt; zzEndReadL)</span>
<span class="nc bnc" id="L698" title="All 2 branches missed.">          zzPeek = zzBufferL[zzMarkedPosL] == '\n';</span>
<span class="nc bnc" id="L699" title="All 2 branches missed.">        else if (zzAtEOF)</span>
<span class="nc" id="L700">          zzPeek = false;</span>
        else {
<span class="nc" id="L702">          boolean eof = zzRefill();</span>
<span class="nc" id="L703">          zzEndReadL = zzEndRead;</span>
<span class="nc" id="L704">          zzMarkedPosL = zzMarkedPos;</span>
<span class="nc" id="L705">          zzBufferL = zzBuffer;</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">          if (eof) </span>
<span class="nc" id="L707">            zzPeek = false;</span>
          else 
<span class="nc bnc" id="L709" title="All 2 branches missed.">            zzPeek = zzBufferL[zzMarkedPosL] == '\n';</span>
        }
<span class="nc bnc" id="L711" title="All 2 branches missed.">        if (zzPeek) yyline--;</span>
      }
<span class="fc" id="L713">      zzAction = -1;</span>

<span class="fc" id="L715">      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;</span>
  
<span class="fc" id="L717">      zzState = ZZ_LEXSTATE[zzLexicalState];</span>


      zzForAction: {
        while (true) {
    
<span class="pc bpc" id="L723" title="1 of 2 branches missed.">          if (zzCurrentPosL &lt; zzEndReadL)</span>
<span class="nc" id="L724">            zzInput = zzBufferL[zzCurrentPosL++];</span>
<span class="pc bpc" id="L725" title="1 of 2 branches missed.">          else if (zzAtEOF) {</span>
<span class="nc" id="L726">            zzInput = YYEOF;</span>
<span class="nc" id="L727">            break zzForAction;</span>
          }
          else {
            // store back cached positions
<span class="fc" id="L731">            zzCurrentPos  = zzCurrentPosL;</span>
<span class="fc" id="L732">            zzMarkedPos   = zzMarkedPosL;</span>
<span class="fc" id="L733">            boolean eof = zzRefill();</span>
            // get translated positions and possibly new buffer
<span class="fc" id="L735">            zzCurrentPosL  = zzCurrentPos;</span>
<span class="fc" id="L736">            zzMarkedPosL   = zzMarkedPos;</span>
<span class="fc" id="L737">            zzBufferL      = zzBuffer;</span>
<span class="fc" id="L738">            zzEndReadL     = zzEndRead;</span>
<span class="pc bpc" id="L739" title="1 of 2 branches missed.">            if (eof) {</span>
<span class="nc" id="L740">              zzInput = YYEOF;</span>
<span class="nc" id="L741">              break zzForAction;</span>
            }
            else {
<span class="fc" id="L744">              zzInput = zzBufferL[zzCurrentPosL++];</span>
            }
          }
<span class="fc" id="L747">          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];</span>
<span class="pc bpc" id="L748" title="1 of 2 branches missed.">          if (zzNext == -1) break zzForAction;</span>
<span class="fc" id="L749">          zzState = zzNext;</span>

<span class="fc" id="L751">          int zzAttributes = zzAttrL[zzState];</span>
<span class="pc bpc" id="L752" title="1 of 2 branches missed.">          if ( (zzAttributes &amp; 1) == 1 ) {</span>
<span class="fc" id="L753">            zzAction = zzState;</span>
<span class="fc" id="L754">            zzMarkedPosL = zzCurrentPosL;</span>
<span class="pc bpc" id="L755" title="1 of 2 branches missed.">            if ( (zzAttributes &amp; 8) == 8 ) break zzForAction;</span>
          }

<span class="nc" id="L758">        }</span>
      }

      // store back cached position
<span class="fc" id="L762">      zzMarkedPos = zzMarkedPosL;</span>

<span class="pc bpc" id="L764" title="6 of 8 branches missed.">      switch (zzAction &lt; 0 ? zzAction : ZZ_ACTION[zzAction]) {</span>
        case 3: 
<span class="nc" id="L766">          { return symbol(sym.PLUS);</span>
          }
<span class="nc" id="L768">        case 4: break;</span>
        case 1: 
<span class="fc" id="L770">          { System.out.println(&quot;Erreur Lexicale : '&quot; +</span>
<span class="fc" id="L771">                            yytext() + &quot;' non reconnu ... ligne &quot; + </span>
<span class="fc" id="L772">                            numLigne()) ;</span>
<span class="fc" id="L773">                         throw new ErreurLexicale() ;</span>
          }
<span class="nc" id="L775">        case 5: break;</span>
        case 2: 
          { 
          }
<span class="nc" id="L779">        case 6: break;</span>
        default: 
<span class="nc bnc" id="L781" title="All 4 branches missed.">          if (zzInput == YYEOF &amp;&amp; zzStartRead == zzCurrentPos) {</span>
<span class="nc" id="L782">            zzAtEOF = true;</span>
<span class="nc" id="L783">            zzDoEOF();</span>
<span class="nc" id="L784">              { return new java_cup.runtime.Symbol(sym.EOF); }</span>
          } 
          else {
<span class="nc" id="L787">            zzScanError(ZZ_NO_MATCH);</span>
          }
      }
<span class="nc" id="L790">    }</span>
  }


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>